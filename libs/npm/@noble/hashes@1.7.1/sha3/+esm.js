/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@noble/hashes@1.7.1/esm/sha3.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import"/npm/@noble/hashes@1.7.1/crypto/+esm.js";function t(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function e(t,...e){if(!((n=t)instanceof Uint8Array||ArrayBuffer.isView(n)&&"Uint8Array"===n.constructor.name))throw new Error("Uint8Array expected");var n;if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function n(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}const s=BigInt(2**32-1),r=BigInt(32);function i(t,e=!1){return e?{h:Number(t&s),l:Number(t>>r&s)}:{h:0|Number(t>>r&s),l:0|Number(t&s)}}function o(t,e=!1){let n=new Uint32Array(t.length),s=new Uint32Array(t.length);for(let r=0;r<t.length;r++){const{h:o,l:h}=i(t[r],e);[n[r],s[r]]=[o,h]}return[n,s]}const h=(()=>68===new Uint8Array(new Uint32Array([287454020]).buffer)[0])();function u(t){for(let n=0;n<t.length;n++)t[n]=(e=t[n])<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255;var e}function f(t){return"string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),e(t),t}class c{clone(){return this._cloneInto()}}const a=[],l=[],d=[],p=BigInt(0),g=BigInt(1),w=BigInt(2),y=BigInt(7),b=BigInt(256),k=BigInt(113);for(let t=0,e=g,n=1,s=0;t<24;t++){[n,s]=[s,(2*n+3*s)%5],a.push(2*(5*s+n)),l.push((t+1)*(t+2)/2%64);let r=p;for(let t=0;t<7;t++)e=(e<<g^(e>>y)*k)%b,e&w&&(r^=g<<(g<<BigInt(t))-g);d.push(r)}const[L,I]=o(d,!0),x=(t,e,n)=>n>32?((t,e,n)=>e<<n-32|t>>>64-n)(t,e,n):((t,e,n)=>t<<n|e>>>32-n)(t,e,n),A=(t,e,n)=>n>32?((t,e,n)=>t<<n-32|e>>>64-n)(t,e,n):((t,e,n)=>e<<n|t>>>32-n)(t,e,n);function O(t,e=24){const n=new Uint32Array(10);for(let s=24-e;s<24;s++){for(let e=0;e<10;e++)n[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){const s=(e+8)%10,r=(e+2)%10,i=n[r],o=n[r+1],h=x(i,o,1)^n[s],u=A(i,o,1)^n[s+1];for(let n=0;n<50;n+=10)t[e+n]^=h,t[e+n+1]^=u}let e=t[2],r=t[3];for(let n=0;n<24;n++){const s=l[n],i=x(e,r,s),o=A(e,r,s),h=a[n];e=t[h],r=t[h+1],t[h]=i,t[h+1]=o}for(let e=0;e<50;e+=10){for(let s=0;s<10;s++)n[s]=t[e+s];for(let s=0;s<10;s++)t[e+s]^=~n[(s+2)%10]&n[(s+4)%10]}t[0]^=L[s],t[1]^=I[s]}n.fill(0)}class U extends c{constructor(e,n,s,r=!1,i=24){if(super(),this.blockLen=e,this.suffix=n,this.outputLen=s,this.enableXOF=r,this.rounds=i,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,t(s),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var o;this.state=new Uint8Array(200),this.state32=(o=this.state,new Uint32Array(o.buffer,o.byteOffset,Math.floor(o.byteLength/4)))}keccak(){h||u(this.state32),O(this.state32,this.rounds),h||u(this.state32),this.posOut=0,this.pos=0}update(t){n(this);const{blockLen:e,state:s}=this,r=(t=f(t)).length;for(let n=0;n<r;){const i=Math.min(e-this.pos,r-n);for(let e=0;e<i;e++)s[this.pos++]^=t[n++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:n,blockLen:s}=this;t[n]^=e,128&e&&n===s-1&&this.keccak(),t[s-1]^=128,this.keccak()}writeInto(t){n(this,!1),e(t),this.finish();const s=this.state,{blockLen:r}=this;for(let e=0,n=t.length;e<n;){this.posOut>=r&&this.keccak();const i=Math.min(r-this.posOut,n-e);t.set(s.subarray(this.posOut,this.posOut+i),e),this.posOut+=i,e+=i}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(e){return t(e),this.xofInto(new Uint8Array(e))}digestInto(t){if(function(t,n){e(t);const s=n.outputLen;if(t.length<s)throw new Error("digestInto() expects output buffer of length at least "+s)}(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:e,suffix:n,outputLen:s,rounds:r,enableXOF:i}=this;return t||(t=new U(e,n,s,i,r)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=r,t.suffix=n,t.outputLen=s,t.enableXOF=i,t.destroyed=this.destroyed,t}}const m=(t,e,n)=>function(t){const e=e=>t().update(f(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}((()=>new U(e,t,n))),B=m(6,144,28),E=m(6,136,32),v=m(6,104,48),F=m(6,72,64),N=m(1,144,28),X=m(1,136,32),M=m(1,104,48),H=m(1,72,64),S=(t,e,n)=>function(t){const e=(e,n)=>t(n).update(f(e)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=e=>t(e),e}(((s={})=>new U(e,t,void 0===s.dkLen?n:s.dkLen,!0))),T=S(31,168,16),_=S(31,136,32);export{U as Keccak,O as keccakP,N as keccak_224,X as keccak_256,M as keccak_384,H as keccak_512,B as sha3_224,E as sha3_256,v as sha3_384,F as sha3_512,T as shake128,_ as shake256};export default null;
//# sourceMappingURL=/sm/0a839fb4f9bac4363e2acfa0704169ae14b885f79002ce99c73f4e650997e94c.map