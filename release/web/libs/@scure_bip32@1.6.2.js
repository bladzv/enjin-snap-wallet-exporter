/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@scure/bip32@1.6.2/lib/esm/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{hmac as e}from"../npm/@noble/hashes@1.7.1/hmac/+esm.js";import{ripemd160 as t}from"../npm/@noble/hashes@1.7.1/ripemd160/+esm.js";import{sha256 as i}from"../npm/@noble/hashes@1.7.1/sha256/+esm.js";import{sha512 as r}from"../npm/@noble/hashes@1.7.1/sha512/+esm.js";import{abytes as n}from"../npm/@noble/hashes@1.7.1/_assert/+esm.js";import{utf8ToBytes as s,concatBytes as o,createView as h,bytesToHex as p,hexToBytes as a}from"../npm/@noble/hashes@1.7.1/utils/+esm.js";import{secp256k1 as d}from"../npm/@noble/curves@1.8.1/secp256k1/+esm.js";import{mod as l}from"../npm/@noble/curves@1.8.1/abstract/modular/+esm.js";import{createBase58check as y}from"../npm/@scure/base@1.2.2/+esm.js";const c=d.ProjectivePoint,u=y(i);function v(e){n(e);const t=0===e.length?"0":p(e);return BigInt("0x"+t)}const w=s("Bitcoin seed"),m={private:76066276,public:76067358},K=2147483648,f=e=>{if(!Number.isSafeInteger(e)||e<0||e>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+e);const t=new Uint8Array(4);return h(t).setUint32(0,e,!1),t};class b{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return e=this.pubHash,h(e).getUint32(0,!1);var e}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this.privKeyBytes||null}get publicKey(){return this.pubKey||null}get privateExtendedKey(){const e=this.privateKey;if(!e)throw new Error("No private key");return u.encode(this.serialize(this.versions.private,o(new Uint8Array([0]),e)))}get publicExtendedKey(){if(!this.pubKey)throw new Error("No public key");return u.encode(this.serialize(this.versions.public,this.pubKey))}static fromMasterSeed(t,i=m){if(n(t),8*t.length<128||8*t.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+t.length);const s=e(r,w,t);return new b({versions:i,chainCode:s.slice(32),privateKey:s.slice(0,32)})}static fromExtendedKey(e,t=m){const i=u.decode(e),r=h(i),n=r.getUint32(0,!1),s={versions:t,depth:i[4],parentFingerprint:r.getUint32(5,!1),index:r.getUint32(9,!1),chainCode:i.slice(13,45)},o=i.slice(45),p=0===o[0];if(n!==t[p?"private":"public"])throw new Error("Version mismatch");return new b(p?{...s,privateKey:o.slice(1)}:{...s,publicKey:o})}static fromJSON(e){return b.fromExtendedKey(e.xpriv)}constructor(e){if(this.depth=0,this.index=0,this.chainCode=null,this.parentFingerprint=0,!e||"object"!=typeof e)throw new Error("HDKey.constructor must not be called directly");if(this.versions=e.versions||m,this.depth=e.depth||0,this.chainCode=e.chainCode||null,this.index=e.index||0,this.parentFingerprint=e.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(e.publicKey&&e.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(e.privateKey){if(!d.utils.isValidPrivateKey(e.privateKey))throw new Error("Invalid private key");this.privKey="bigint"==typeof e.privateKey?e.privateKey:v(e.privateKey),this.privKeyBytes=function(e){if("bigint"!=typeof e)throw new Error("bigint expected");return a(e.toString(16).padStart(64,"0"))}(this.privKey),this.pubKey=d.getPublicKey(e.privateKey,!0)}else{if(!e.publicKey)throw new Error("HDKey: no public or private key provided");this.pubKey=c.fromHex(e.publicKey).toRawBytes(!0)}var r;this.pubHash=(r=this.pubKey,t(i(r)))}derive(e){if(!/^[mM]'?/.test(e))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(e))return this;const t=e.replace(/^[mM]'?\//,"").split("/");let i=this;for(const e of t){const t=/^(\d+)('?)$/.exec(e),r=t&&t[1];if(!t||3!==t.length||"string"!=typeof r)throw new Error("invalid child index: "+e);let n=+r;if(!Number.isSafeInteger(n)||n>=K)throw new Error("Invalid index");"'"===t[2]&&(n+=K),i=i.deriveChild(n)}return i}deriveChild(t){if(!this.pubKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let i=f(t);if(t>=K){const e=this.privateKey;if(!e)throw new Error("Could not derive hardened child key");i=o(new Uint8Array([0]),e,i)}else i=o(this.pubKey,i);const n=e(r,this.chainCode,i),s=v(n.slice(0,32)),h=n.slice(32);if(!d.utils.isValidPrivateKey(s))throw new Error("Tweak bigger than curve order");const p={versions:this.versions,chainCode:h,depth:this.depth+1,parentFingerprint:this.fingerprint,index:t};try{if(this.privateKey){const e=l(this.privKey+s,d.CURVE.n);if(!d.utils.isValidPrivateKey(e))throw new Error("The tweak was out of range or the resulted private key is invalid");p.privateKey=e}else{const e=c.fromHex(this.pubKey).add(c.fromPrivateKey(s));if(e.equals(c.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");p.publicKey=e.toRawBytes(!0)}return new b(p)}catch(e){return this.deriveChild(t+1)}}sign(e){if(!this.privateKey)throw new Error("No privateKey set!");return n(e,32),d.sign(e,this.privKey).toCompactRawBytes()}verify(e,t){if(n(e,32),n(t,64),!this.publicKey)throw new Error("No publicKey set!");let i;try{i=d.Signature.fromCompact(t)}catch(e){return!1}return d.verify(i,e,this.publicKey)}wipePrivateData(){return this.privKey=void 0,this.privKeyBytes&&(this.privKeyBytes.fill(0),this.privKeyBytes=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(e,t){if(!this.chainCode)throw new Error("No chainCode set");return n(t,33),o(f(e),new Uint8Array([this.depth]),f(this.parentFingerprint),f(this.index),this.chainCode,t)}}export{K as HARDENED_OFFSET,b as HDKey};export default null;
//# sourceMappingURL=/sm/1a55f6689283fa9ee6d5a035a6b5deb451156aacdf248ad5424dbd6b509d319c.map