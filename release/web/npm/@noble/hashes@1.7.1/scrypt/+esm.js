/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@noble/hashes@1.7.1/esm/scrypt.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import"/npm/@noble/hashes@1.7.1/crypto/+esm.js";function t(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function e(t,...e){if(!((n=t)instanceof Uint8Array||ArrayBuffer.isView(n)&&"Uint8Array"===n.constructor.name))throw new Error("Uint8Array expected");var n;if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function n(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");t(e.outputLen),t(e.blockLen)}function s(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function o(t){return new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4))}function r(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function i(t,e){return t<<32-e|t>>>e}function h(t,e){return t<<e|t>>>32-e>>>0}const c=(()=>68===new Uint8Array(new Uint32Array([287454020]).buffer)[0])();function u(t){for(let n=0;n<t.length;n++)t[n]=(e=t[n])<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255;var e}const f=async()=>{};async function a(t,e,n){let s=Date.now();for(let o=0;o<t;o++){n(o);const t=Date.now()-s;t>=0&&t<e||(await f(),s+=t)}}function l(t){return"string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),e(t),t}class d{clone(){return this._cloneInto()}}function p(t,e){if(void 0!==e&&"[object Object]"!=={}.toString.call(e))throw new Error("Options should be object or undefined");return Object.assign(t,e)}function y(t){const e=e=>t().update(l(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}class w extends d{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,n(t);const s=l(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,r=new Uint8Array(o);r.set(s.length>o?t.create().update(s).digest():s);for(let t=0;t<r.length;t++)r[t]^=54;this.iHash.update(r),this.oHash=t.create();for(let t=0;t<r.length;t++)r[t]^=106;this.oHash.update(r),r.fill(0)}update(t){return s(this),this.iHash.update(t),this}digestInto(t){s(this),e(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:s,destroyed:o,blockLen:r,outputLen:i}=this;return t.finished=s,t.destroyed=o,t.blockLen=r,t.outputLen=i,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const g=(t,e,n)=>new w(t,e).update(n).digest();function b(e,s,o,i){const{c:h,dkLen:c,DK:u,PRF:f,PRFSalt:a}=function(e,s,o,r){n(e);const i=p({dkLen:32,asyncTick:10},r),{c:h,dkLen:c,asyncTick:u}=i;if(t(h),t(c),t(u),h<1)throw new Error("PBKDF2: iterations (c) should be >= 1");const f=l(s),a=l(o),d=new Uint8Array(c),y=g.create(e,f),w=y._cloneInto().update(a);return{c:h,dkLen:c,asyncTick:u,DK:d,PRF:y,PRFSalt:w}}(e,s,o,i);let d;const y=new Uint8Array(4),w=r(y),b=new Uint8Array(f.outputLen);for(let t=1,e=0;e<c;t++,e+=f.outputLen){const n=u.subarray(e,e+f.outputLen);w.setInt32(0,t,!1),(d=a._cloneInto(d)).update(y).digestInto(b),n.set(b.subarray(0,n.length));for(let t=1;t<h;t++){f._cloneInto(d).update(b).digestInto(b);for(let t=0;t<n.length;t++)n[t]^=b[t]}}return function(t,e,n,s,o){return t.destroy(),e.destroy(),s&&s.destroy(),o.fill(0),n}(f,a,u,d,b)}function L(t,e,n){return t&e^t&n^e&n}g.create=(t,e)=>new w(t,e);class k extends d{constructor(t,e,n,s){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=r(this.buffer)}update(t){s(this);const{view:e,buffer:n,blockLen:o}=this,i=(t=l(t)).length;for(let s=0;s<i;){const h=Math.min(o-this.pos,i-s);if(h!==o)n.set(t.subarray(s,s+h),this.pos),this.pos+=h,s+=h,this.pos===o&&(this.process(e,0),this.pos=0);else{const e=r(t);for(;o<=i-s;s+=o)this.process(e,s)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){s(this),function(t,n){e(t);const s=n.outputLen;if(t.length<s)throw new Error("digestInto() expects output buffer of length at least "+s)}(t,this),this.finished=!0;const{buffer:n,view:o,blockLen:i,isLE:h}=this;let{pos:c}=this;n[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>i-c&&(this.process(o,0),c=0);for(let t=c;t<i;t++)n[t]=0;!function(t,e,n,s){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,s);const o=BigInt(32),r=BigInt(4294967295),i=Number(n>>o&r),h=Number(n&r),c=s?4:0,u=s?0:4;t.setUint32(e+c,i,s),t.setUint32(e+u,h,s)}(o,i-8,BigInt(8*this.length),h),this.process(o,0);const u=r(t),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=f/4,l=this.get();if(a>l.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<a;t++)u.setUint32(4*t,l[t],h)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:s,finished:o,destroyed:r,pos:i}=this;return t.length=s,t.pos=i,t.finished=o,t.destroyed=r,s%e&&t.buffer.set(n),t}}const H=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),E=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),m=new Uint32Array(64);class A extends k{constructor(){super(64,32,8,!1),this.A=0|E[0],this.B=0|E[1],this.C=0|E[2],this.D=0|E[3],this.E=0|E[4],this.F=0|E[5],this.G=0|E[6],this.H=0|E[7]}get(){const{A:t,B:e,C:n,D:s,E:o,F:r,G:i,H:h}=this;return[t,e,n,s,o,r,i,h]}set(t,e,n,s,o,r,i,h){this.A=0|t,this.B=0|e,this.C=0|n,this.D=0|s,this.E=0|o,this.F=0|r,this.G=0|i,this.H=0|h}process(t,e){for(let n=0;n<16;n++,e+=4)m[n]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=m[t-15],n=m[t-2],s=i(e,7)^i(e,18)^e>>>3,o=i(n,17)^i(n,19)^n>>>10;m[t]=o+m[t-7]+s+m[t-16]|0}let{A:n,B:s,C:o,D:r,E:h,F:c,G:u,H:f}=this;for(let t=0;t<64;t++){const e=f+(i(h,6)^i(h,11)^i(h,25))+((a=h)&c^~a&u)+H[t]+m[t]|0,l=(i(n,2)^i(n,13)^i(n,22))+L(n,s,o)|0;f=u,u=c,c=h,h=r+e|0,r=o,o=s,s=n,n=e+l|0}var a;n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,r=r+this.D|0,h=h+this.E|0,c=c+this.F|0,u=u+this.G|0,f=f+this.H|0,this.set(n,s,o,r,h,c,u,f)}roundClean(){m.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const U=y((()=>new A));function x(t,e,n,s,o,r){let i=t[e++]^n[s++],c=t[e++]^n[s++],u=t[e++]^n[s++],f=t[e++]^n[s++],a=t[e++]^n[s++],l=t[e++]^n[s++],d=t[e++]^n[s++],p=t[e++]^n[s++],y=t[e++]^n[s++],w=t[e++]^n[s++],g=t[e++]^n[s++],b=t[e++]^n[s++],L=t[e++]^n[s++],k=t[e++]^n[s++],H=t[e++]^n[s++],E=t[e++]^n[s++],m=i,A=c,U=u,x=f,I=a,B=l,C=d,v=p,D=y,S=w,F=g,O=b,_=L,N=k,T=H,M=E;for(let t=0;t<8;t+=2)I^=h(m+_|0,7),D^=h(I+m|0,9),_^=h(D+I|0,13),m^=h(_+D|0,18),S^=h(B+A|0,7),N^=h(S+B|0,9),A^=h(N+S|0,13),B^=h(A+N|0,18),T^=h(F+C|0,7),U^=h(T+F|0,9),C^=h(U+T|0,13),F^=h(C+U|0,18),x^=h(M+O|0,7),v^=h(x+M|0,9),O^=h(v+x|0,13),M^=h(O+v|0,18),A^=h(m+x|0,7),U^=h(A+m|0,9),x^=h(U+A|0,13),m^=h(x+U|0,18),C^=h(B+I|0,7),v^=h(C+B|0,9),I^=h(v+C|0,13),B^=h(I+v|0,18),O^=h(F+S|0,7),D^=h(O+F|0,9),S^=h(D+O|0,13),F^=h(S+D|0,18),_^=h(M+T|0,7),N^=h(_+M|0,9),T^=h(N+_|0,13),M^=h(T+N|0,18);o[r++]=i+m|0,o[r++]=c+A|0,o[r++]=u+U|0,o[r++]=f+x|0,o[r++]=a+I|0,o[r++]=l+B|0,o[r++]=d+C|0,o[r++]=p+v|0,o[r++]=y+D|0,o[r++]=w+S|0,o[r++]=g+F|0,o[r++]=b+O|0,o[r++]=L+_|0,o[r++]=k+N|0,o[r++]=H+T|0,o[r++]=E+M|0}function I(t,e,n,s,o){let r=s+0,i=s+16*o;for(let s=0;s<16;s++)n[i+s]=t[e+16*(2*o-1)+s];for(let s=0;s<o;s++,r+=16,e+=16)x(n,i,t,e,n,r),s>0&&(i+=16),x(n,r,t,e+=16,n,i)}function B(e,n,s){const r=p({dkLen:32,asyncTick:10,maxmem:1073742848},s),{N:i,r:h,p:c,dkLen:u,asyncTick:f,maxmem:a,onProgress:l}=r;if(t(i),t(h),t(c),t(u),t(f),t(a),void 0!==l&&"function"!=typeof l)throw new Error("progressCb should be function");const d=128*h,y=d/4;if(i<=1||i&i-1||i>2**32)throw new Error("Scrypt: N must be larger than 1, a power of 2, and less than 2^32");if(c<0||c>137438953440/d)throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");if(u<0||u>137438953440)throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");if(d*(i+c)>a)throw new Error("Scrypt: memused is bigger than maxMem. Expected 128 * r * (N + p) > maxmem of "+a);const w=b(U,e,n,{c:1,dkLen:d*c}),g=o(w),L=o(new Uint8Array(d*i)),k=o(new Uint8Array(d));let H=()=>{};if(l){const t=2*i*c,e=Math.max(Math.floor(t/1e4),1);let n=0;H=()=>{n++,!l||n%e&&n!==t||l(n/t)}}return{N:i,r:h,p:c,dkLen:u,blockSize32:y,V:L,B32:g,B:w,tmp:k,blockMixCb:H,asyncTick:f}}function C(t,e,n,s,o){const r=b(U,t,n,{c:1,dkLen:e});return n.fill(0),s.fill(0),o.fill(0),r}function v(t,e,n){const{N:s,r:o,p:r,dkLen:i,blockSize32:h,V:f,B32:a,B:l,tmp:d,blockMixCb:p}=B(t,e,n);c||u(a);for(let t=0;t<r;t++){const e=h*t;for(let t=0;t<h;t++)f[t]=a[e+t];for(let t=0,e=0;t<s-1;t++)I(f,e,f,e+=h,o),p();I(f,(s-1)*h,a,e,o),p();for(let t=0;t<s;t++){const t=a[e+h-16]%s;for(let n=0;n<h;n++)d[n]=a[e+n]^f[t*h+n];I(d,0,a,e,o),p()}}return c||u(a),C(t,i,l,f,d)}async function D(t,e,n){const{N:s,r:o,p:r,dkLen:i,blockSize32:h,V:f,B32:l,B:d,tmp:p,blockMixCb:y,asyncTick:w}=B(t,e,n);c||u(l);for(let t=0;t<r;t++){const e=h*t;for(let t=0;t<h;t++)f[t]=l[e+t];let n=0;await a(s-1,w,(()=>{I(f,n,f,n+=h,o),y()})),I(f,(s-1)*h,l,e,o),y(),await a(s,w,(()=>{const t=l[e+h-16]%s;for(let n=0;n<h;n++)p[n]=l[e+n]^f[t*h+n];I(p,0,l,e,o),y()}))}return c||u(l),C(t,i,d,f,p)}export{v as scrypt,D as scryptAsync};export default null;
//# sourceMappingURL=/sm/659c2d3850c26cd78b9f767df3990d66312fc006b8c9dfc09f2b2d30d0d3d67d.map