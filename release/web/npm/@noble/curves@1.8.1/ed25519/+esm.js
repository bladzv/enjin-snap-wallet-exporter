/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@noble/curves@1.8.1/esm/ed25519.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{sha512 as t}from"/npm/@noble/hashes@1.7.1/sha512/+esm.js";import{randomBytes as e,utf8ToBytes as n,concatBytes as r}from"/npm/@noble/hashes@1.7.1/utils/+esm.js";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const o=BigInt(0),i=BigInt(1),s=BigInt(2);function f(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function c(t){if(!f(t))throw new Error("Uint8Array expected")}function a(t,e){if("boolean"!=typeof e)throw new Error(t+" boolean expected, got "+e)}const u=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function l(t){c(t);let e="";for(let n=0;n<t.length;n++)e+=u[t[n]];return e}function d(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return""===t?o:BigInt("0x"+t)}const h=48,g=57,w=65,p=70,m=97,y=102;function E(t){return t>=h&&t<=g?t-h:t>=w&&t<=p?t-(w-10):t>=m&&t<=y?t-(m-10):void 0}function B(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let e=0,o=0;e<n;e++,o+=2){const n=E(t.charCodeAt(o)),i=E(t.charCodeAt(o+1));if(void 0===n||void 0===i){const e=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+o)}r[e]=16*n+i}return r}function x(t){return d(l(t))}function b(t){return c(t),d(l(Uint8Array.from(t).reverse()))}function v(t,e){return B(t.toString(16).padStart(2*e,"0"))}function I(t,e){return v(t,e).reverse()}function S(t,e,n){let r;if("string"==typeof e)try{r=B(e)}catch(e){throw new Error(t+" must be hex string or Uint8Array, cause: "+e)}else{if(!f(e))throw new Error(t+" must be hex string or Uint8Array");r=Uint8Array.from(e)}const o=r.length;if("number"==typeof n&&o!==n)throw new Error(t+" of length "+n+" expected, got "+o);return r}function R(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];c(r),e+=r.length}const n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const o=t[e];n.set(o,r),r+=o.length}return n}function A(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}const O=t=>"bigint"==typeof t&&o<=t;function q(t,e,n,r){if(!function(t,e,n){return O(t)&&O(e)&&O(n)&&e<=t&&t<n}(e,n,r))throw new Error("expected valid "+t+": "+n+" <= n < "+r+", got "+e)}const C={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||f(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function N(t,e,n={}){const r=(e,n,r)=>{const o=C[n];if("function"!=typeof o)throw new Error("invalid validator function");const i=t[e];if(!(r&&void 0===i||o(i,t)))throw new Error("param "+String(e)+" is invalid. Expected "+n+", got "+i)};for(const[t,n]of Object.entries(e))r(t,n,!1);for(const[t,e]of Object.entries(n))r(t,e,!0);return t}function U(t){const e=new WeakMap;return(n,...r)=>{const o=e.get(n);if(void 0!==o)return o;const i=t(n,...r);return e.set(n,i),i}}const T=BigInt(0),z=BigInt(1),P=BigInt(2),V=BigInt(3),L=BigInt(4),_=BigInt(5),F=BigInt(8);function M(t,e){const n=t%e;return n>=T?n:e+n}function D(t,e,n){if(e<T)throw new Error("invalid exponent, negatives unsupported");if(n<=T)throw new Error("invalid modulus");if(n===z)return T;let r=z;for(;e>T;)e&z&&(r=r*t%n),t=t*t%n,e>>=z;return r}function Z(t,e,n){let r=t;for(;e-- >T;)r*=r,r%=n;return r}function H(t,e){if(t===T)throw new Error("invert: expected non-zero number");if(e<=T)throw new Error("invert: expected positive modulus, got "+e);let n=M(t,e),r=e,o=T,i=z;for(;n!==T;){const t=r%n,e=o-i*(r/n);r=n,n=t,o=i,i=e}if(r!==z)throw new Error("invert: does not exist");return M(o,e)}function j(t){if(t%L===V){const e=(t+z)/L;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}}if(t%F===_){const e=(t-_)/F;return function(t,n){const r=t.mul(n,P),o=t.pow(r,e),i=t.mul(n,o),s=t.mul(t.mul(i,P),o),f=t.mul(i,t.sub(s,t.ONE));if(!t.eql(t.sqr(f),n))throw new Error("Cannot find square root");return f}}return function(t){const e=(t-z)/P;let n,r,o;for(n=t-z,r=0;n%P===T;n/=P,r++);for(o=P;o<t&&D(o,e,t)!==t-z;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(1===r){const e=(t+z)/L;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}}const i=(n+z)/P;return function(t,s){if(t.pow(s,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let f=r,c=t.pow(t.mul(t.ONE,o),n),a=t.pow(s,i),u=t.pow(s,n);for(;!t.eql(u,t.ONE);){if(t.eql(u,t.ZERO))return t.ZERO;let e=1;for(let n=t.sqr(u);e<f&&!t.eql(n,t.ONE);e++)n=t.sqr(n);const n=t.pow(c,z<<BigInt(f-e-1));c=t.sqr(n),a=t.mul(a,n),u=t.mul(u,c),f=e}return a}}(t)}const k=(t,e)=>(M(t,e)&z)===z,G=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function W(t,e){const n=void 0!==e?e:t.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function K(t,e,n=!1,r={}){if(t<=T)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:o,nByteLength:f}=W(t,e);if(f>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const a=Object.freeze({ORDER:t,isLE:n,BITS:o,BYTES:f,MASK:(u=o,(s<<BigInt(u-1))-i),ZERO:T,ONE:z,create:e=>M(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("invalid field element: expected bigint, got "+typeof e);return T<=e&&e<t},is0:t=>t===T,isOdd:t=>(t&z)===z,neg:e=>M(-e,t),eql:(t,e)=>t===e,sqr:e=>M(e*e,t),add:(e,n)=>M(e+n,t),sub:(e,n)=>M(e-n,t),mul:(e,n)=>M(e*n,t),pow:(t,e)=>function(t,e,n){if(n<T)throw new Error("invalid exponent, negatives unsupported");if(n===T)return t.ONE;if(n===z)return e;let r=t.ONE,o=e;for(;n>T;)n&z&&(r=t.mul(r,o)),o=t.sqr(o),n>>=z;return r}(a,t,e),div:(e,n)=>M(e*H(n,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>H(e,t),sqrt:r.sqrt||(e=>(c||(c=j(t)),c(a,e))),invertBatch:t=>function(t,e){const n=new Array(e.length),r=e.reduce(((e,r,o)=>t.is0(r)?e:(n[o]=e,t.mul(e,r))),t.ONE),o=t.inv(r);return e.reduceRight(((e,r,o)=>t.is0(r)?e:(n[o]=t.mul(e,n[o]),t.mul(e,r))),o),n}(a,t),cmov:(t,e,n)=>n?e:t,toBytes:t=>n?I(t,f):v(t,f),fromBytes:t=>{if(t.length!==f)throw new Error("Field.fromBytes: expected "+f+" bytes, got "+t.length);return n?b(t):x(t)}});var u;return Object.freeze(a)}const Y=BigInt(0),X=BigInt(1);function J(t,e){const n=e.negate();return t?n:e}function Q(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function $(t,e){Q(t,e);return{windows:Math.ceil(e/t)+1,windowSize:2**(t-1)}}const tt=new WeakMap,et=new WeakMap;function nt(t){return et.get(t)||1}function rt(t,e,n,r){if(function(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach(((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)}))}(n,t),function(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach(((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)}))}(r,e),n.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const s=t.ZERO,f=function(t){let e;for(e=0;t>o;t>>=i,e+=1);return e}(BigInt(n.length)),c=f>12?f-3:f>4?f-2:f?2:1,a=(1<<c)-1,u=new Array(a+1).fill(s);let l=s;for(let t=Math.floor((e.BITS-1)/c)*c;t>=0;t-=c){u.fill(s);for(let e=0;e<r.length;e++){const o=r[e],i=Number(o>>BigInt(t)&BigInt(a));u[i]=u[i].add(n[e])}let e=s;for(let t=u.length-1,n=s;t>0;t--)n=n.add(u[t]),e=e.add(n);if(l=l.add(e),0!==t)for(let t=0;t<c;t++)l=l.double()}return l}function ot(t){return N(t.Fp,G.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),N(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...W(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}const it=BigInt(0),st=BigInt(1),ft=BigInt(2),ct=BigInt(8),at={zip215:!0};function ut(t){const e=function(t){const e=ot(t);return N(t,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}(t),{Fp:n,n:r,prehash:o,hash:i,randomBytes:s,nByteLength:f,h:c}=e,u=ft<<BigInt(8*f)-st,d=n.create,h=K(e.n,e.nBitLength),g=e.uvRatio||((t,e)=>{try{return{isValid:!0,value:n.sqrt(t*n.inv(e))}}catch(t){return{isValid:!1,value:it}}}),w=e.adjustScalarBytes||(t=>t),p=e.domain||((t,e,n)=>{if(a("phflag",n),e.length||n)throw new Error("Contexts/pre-hash are not supported");return t});function m(t,e){q("coordinate "+t,e,it,u)}function y(t){if(!(t instanceof x))throw new Error("ExtendedPoint expected")}const E=U(((t,e)=>{const{ex:r,ey:o,ez:i}=t,s=t.is0();null==e&&(e=s?ct:n.inv(i));const f=d(r*e),c=d(o*e),a=d(i*e);if(s)return{x:it,y:st};if(a!==st)throw new Error("invZ was invalid");return{x:f,y:c}})),B=U((t=>{const{a:n,d:r}=e;if(t.is0())throw new Error("bad point: ZERO");const{ex:o,ey:i,ez:s,et:f}=t,c=d(o*o),a=d(i*i),u=d(s*s),l=d(u*u),h=d(c*n);if(d(u*d(h+a))!==d(l+d(r*d(c*a))))throw new Error("bad point: equation left != right (1)");if(d(o*i)!==d(s*f))throw new Error("bad point: equation left != right (2)");return!0}));class x{constructor(t,e,n,r){this.ex=t,this.ey=e,this.ez=n,this.et=r,m("x",t),m("y",e),m("z",n),m("t",r),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(t){if(t instanceof x)throw new Error("extended point not allowed");const{x:e,y:n}=t||{};return m("x",e),m("y",n),new x(e,n,st,d(e*n))}static normalizeZ(t){const e=n.invertBatch(t.map((t=>t.ez)));return t.map(((t,n)=>t.toAffine(e[n]))).map(x.fromAffine)}static msm(t,e){return rt(x,h,t,e)}_setWindowSize(t){O.setWindowSize(this,t)}assertValidity(){B(this)}equals(t){y(t);const{ex:e,ey:n,ez:r}=this,{ex:o,ey:i,ez:s}=t,f=d(e*s),c=d(o*r),a=d(n*s),u=d(i*r);return f===c&&a===u}is0(){return this.equals(x.ZERO)}negate(){return new x(d(-this.ex),this.ey,this.ez,d(-this.et))}double(){const{a:t}=e,{ex:n,ey:r,ez:o}=this,i=d(n*n),s=d(r*r),f=d(ft*d(o*o)),c=d(t*i),a=n+r,u=d(d(a*a)-i-s),l=c+s,h=l-f,g=c-s,w=d(u*h),p=d(l*g),m=d(u*g),y=d(h*l);return new x(w,p,y,m)}add(t){y(t);const{a:n,d:r}=e,{ex:o,ey:i,ez:s,et:f}=this,{ex:c,ey:a,ez:u,et:l}=t;if(n===BigInt(-1)){const t=d((i-o)*(a+c)),e=d((i+o)*(a-c)),n=d(e-t);if(n===it)return this.double();const r=d(s*ft*l),h=d(f*ft*u),g=h+r,w=e+t,p=h-r,m=d(g*n),y=d(w*p),E=d(g*p),B=d(n*w);return new x(m,y,B,E)}const h=d(o*c),g=d(i*a),w=d(f*r*l),p=d(s*u),m=d((o+i)*(c+a)-h-g),E=p-w,B=p+w,b=d(g-n*h),v=d(m*E),I=d(B*b),S=d(m*b),R=d(E*B);return new x(v,I,R,S)}subtract(t){return this.add(t.negate())}wNAF(t){return O.wNAFCached(this,t,x.normalizeZ)}multiply(t){const e=t;q("scalar",e,st,r);const{p:n,f:o}=this.wNAF(e);return x.normalizeZ([n,o])[0]}multiplyUnsafe(t,e=x.ZERO){const n=t;return q("scalar",n,it,r),n===it?A:this.is0()||n===st?this:O.wNAFCachedUnsafe(this,n,x.normalizeZ,e)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return O.unsafeLadder(this,r).is0()}toAffine(t){return E(this,t)}clearCofactor(){const{h:t}=e;return t===st?this:this.multiplyUnsafe(t)}static fromHex(t,r=!1){const{d:o,a:i}=e,s=n.BYTES;t=S("pointHex",t,s),a("zip215",r);const f=t.slice(),c=t[s-1];f[s-1]=-129&c;const l=b(f),h=r?u:n.ORDER;q("pointHex.y",l,it,h);const w=d(l*l),p=d(w-st),m=d(o*w-i);let{isValid:y,value:E}=g(p,m);if(!y)throw new Error("Point.fromHex: invalid y coordinate");const B=(E&st)===st,v=!!(128&c);if(!r&&E===it&&v)throw new Error("Point.fromHex: x=0 and x_0=1");return v!==B&&(E=d(-E)),x.fromAffine({x:E,y:l})}static fromPrivateKey(t){return V(t).point}toRawBytes(){const{x:t,y:e}=this.toAffine(),r=I(e,n.BYTES);return r[r.length-1]|=t&st?128:0,r}toHex(){return l(this.toRawBytes())}}x.BASE=new x(e.Gx,e.Gy,st,d(e.Gx*e.Gy)),x.ZERO=new x(it,st,st,it);const{BASE:v,ZERO:A}=x,O=(C=x,T=8*f,{constTimeNegate:J,hasPrecomputes:t=>1!==nt(t),unsafeLadder(t,e,n=C.ZERO){let r=t;for(;e>Y;)e&X&&(n=n.add(r)),r=r.double(),e>>=X;return n},precomputeWindow(t,e){const{windows:n,windowSize:r}=$(e,T),o=[];let i=t,s=i;for(let t=0;t<n;t++){s=i,o.push(s);for(let t=1;t<r;t++)s=s.add(i),o.push(s);i=s.double()}return o},wNAF(t,e,n){const{windows:r,windowSize:o}=$(t,T);let i=C.ZERO,s=C.BASE;const f=BigInt(2**t-1),c=2**t,a=BigInt(t);for(let t=0;t<r;t++){const r=t*o;let u=Number(n&f);n>>=a,u>o&&(u-=c,n+=X);const l=r,d=r+Math.abs(u)-1,h=t%2!=0,g=u<0;0===u?s=s.add(J(h,e[l])):i=i.add(J(g,e[d]))}return{p:i,f:s}},wNAFUnsafe(t,e,n,r=C.ZERO){const{windows:o,windowSize:i}=$(t,T),s=BigInt(2**t-1),f=2**t,c=BigInt(t);for(let t=0;t<o;t++){const o=t*i;if(n===Y)break;let a=Number(n&s);if(n>>=c,a>i&&(a-=f,n+=X),0===a)continue;let u=e[o+Math.abs(a)-1];a<0&&(u=u.negate()),r=r.add(u)}return r},getPrecomputes(t,e,n){let r=tt.get(e);return r||(r=this.precomputeWindow(e,t),1!==t&&tt.set(e,n(r))),r},wNAFCached(t,e,n){const r=nt(t);return this.wNAF(r,this.getPrecomputes(r,t,n),e)},wNAFCachedUnsafe(t,e,n,r){const o=nt(t);return 1===o?this.unsafeLadder(t,e,r):this.wNAFUnsafe(o,this.getPrecomputes(o,t,n),e,r)},setWindowSize(t,e){Q(e,T),et.set(t,e),tt.delete(t)}});var C,T;function z(t){return M(t,r)}function P(t){return z(b(t))}function V(t){const e=n.BYTES;t=S("private key",t,e);const r=S("hashed private key",i(t),2*e),o=w(r.slice(0,e)),s=r.slice(e,2*e),f=P(o),c=v.multiply(f),a=c.toRawBytes();return{head:o,prefix:s,scalar:f,point:c,pointBytes:a}}function L(t=new Uint8Array,...e){const n=R(...e);return P(i(p(n,S("context",t),!!o)))}const _=at;v._setWindowSize(8);return{CURVE:e,getPublicKey:function(t){return V(t).pointBytes},sign:function(t,e,i={}){t=S("message",t),o&&(t=o(t));const{prefix:s,scalar:f,pointBytes:c}=V(e),a=L(i.context,s,t),u=v.multiply(a).toRawBytes(),l=z(a+L(i.context,u,c,t)*f);return q("signature.s",l,it,r),S("result",R(u,I(l,n.BYTES)),2*n.BYTES)},verify:function(t,e,r,i=_){const{context:s,zip215:f}=i,c=n.BYTES;t=S("signature",t,2*c),e=S("message",e),r=S("publicKey",r,c),void 0!==f&&a("zip215",f),o&&(e=o(e));const u=b(t.slice(c,2*c));let l,d,h;try{l=x.fromHex(r,f),d=x.fromHex(t.slice(0,c),f),h=v.multiplyUnsafe(u)}catch(t){return!1}if(!f&&l.isSmallOrder())return!1;const g=L(s,d.toRawBytes(),l.toRawBytes(),e);return d.add(l.multiplyUnsafe(g)).subtract(h).clearCofactor().equals(x.ZERO)},ExtendedPoint:x,utils:{getExtendedPublicKey:V,randomPrivateKey:()=>s(n.BYTES),precompute:(t=8,e=x.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)}}}const lt=x;function dt(t,e){if(gt(t),gt(e),t<0||t>=1<<8*e)throw new Error("invalid I2OSP input: "+t);const n=Array.from({length:e}).fill(0);for(let r=e-1;r>=0;r--)n[r]=255&t,t>>>=8;return new Uint8Array(n)}function ht(t,e){const n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r]^e[r];return n}function gt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function wt(t,e,n,r){c(t),c(e),gt(n),e.length>255&&(e=r(R(A("H2C-OVERSIZE-DST-"),e)));const{outputLen:o,blockLen:i}=r,s=Math.ceil(n/o);if(n>65535||s>255)throw new Error("expand_message_xmd: invalid lenInBytes");const f=R(e,dt(e.length,1)),a=dt(0,i),u=dt(n,2),l=new Array(s),d=r(R(a,t,u,dt(0,1),f));l[0]=r(R(d,dt(1,1),f));for(let t=1;t<=s;t++){const e=[ht(d,l[t-1]),dt(t+1,1),f];l[t]=r(R(...e))}return R(...l).slice(0,n)}function pt(t,e,n){N(n,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:i,hash:s,expand:f,DST:a}=n;c(t),gt(e);const u="string"==typeof a?A(a):a,l=r.toString(2).length,d=Math.ceil((l+o)/8),h=e*i*d;let g;if("xmd"===f)g=wt(t,u,h,s);else if("xof"===f)g=function(t,e,n,r,o){if(c(t),c(e),gt(n),e.length>255){const t=Math.ceil(2*r/8);e=o.create({dkLen:t}).update(A("H2C-OVERSIZE-DST-")).update(e).digest()}if(n>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:n}).update(t).update(dt(n,2)).update(e).update(dt(e.length,1)).digest()}(t,u,h,o,s);else{if("_internal_pass"!==f)throw new Error('expand must be "xmd" or "xof"');g=t}const w=new Array(e);for(let t=0;t<e;t++){const e=new Array(i);for(let n=0;n<i;n++){const o=d*(n+t*i),s=g.subarray(o,o+d);e[n]=M(lt(s),r)}w[t]=e}return w}const mt=BigInt(0),yt=BigInt(1);function Et(t){const e=(N(n=t,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...n}));var n;const{P:r}=e,o=t=>M(t,r),i=e.montgomeryBits,s=Math.ceil(i/8),f=e.nByteLength,c=e.adjustScalarBytes||(t=>t),a=e.powPminus2||(t=>D(t,r-BigInt(2),r));function u(t,e,n){const r=o(t*(e-n));return[e=o(e-r),n=o(n+r)]}const l=(e.a-BigInt(2))/BigInt(4);function d(t){return I(o(t),s)}function h(t,e){const n=function(t){const e=S("u coordinate",t,s);return 32===f&&(e[31]&=127),b(e)}(e),h=function(t,e){q("u",t,mt,r),q("scalar",e,mt,r);const n=e,s=t;let f,c=yt,d=mt,h=t,g=yt,w=mt;for(let t=BigInt(i-1);t>=mt;t--){const e=n>>t&yt;w^=e,f=u(w,c,h),c=f[0],h=f[1],f=u(w,d,g),d=f[0],g=f[1],w=e;const r=c+d,i=o(r*r),a=c-d,p=o(a*a),m=i-p,y=h+g,E=o((h-g)*r),B=o(y*a),x=E+B,b=E-B;h=o(x*x),g=o(s*o(b*b)),c=o(i*p),d=o(m*(i+o(l*m)))}f=u(w,c,h),c=f[0],h=f[1],f=u(w,d,g),d=f[0],g=f[1];const p=a(d);return o(c*p)}(n,function(t){const e=S("scalar",t),n=e.length;if(n!==s&&n!==f)throw new Error("invalid scalar, expected "+s+" or "+f+" bytes, got "+n);return b(c(e))}(t));if(h===mt)throw new Error("invalid private or public key received");return d(h)}const g=d(e.Gu);function w(t){return h(t,g)}return{scalarMult:h,scalarMultBase:w,getSharedSecret:(t,e)=>h(t,e),getPublicKey:t=>w(t),utils:{randomPrivateKey:()=>e.randomBytes(e.nByteLength)},GuBytes:g}}const Bt=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),xt=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),bt=BigInt(0),vt=BigInt(1),It=BigInt(2),St=BigInt(3),Rt=BigInt(5),At=BigInt(8);function Ot(t){const e=BigInt(10),n=BigInt(20),r=BigInt(40),o=BigInt(80),i=Bt,s=t*t%i*t%i,f=Z(s,It,i)*s%i,c=Z(f,vt,i)*t%i,a=Z(c,Rt,i)*c%i,u=Z(a,e,i)*a%i,l=Z(u,n,i)*u%i,d=Z(l,r,i)*l%i,h=Z(d,o,i)*d%i,g=Z(h,o,i)*d%i,w=Z(g,e,i)*a%i;return{pow_p_5_8:Z(w,It,i)*t%i,b2:s}}function qt(t){return t[0]&=248,t[31]&=127,t[31]|=64,t}function Ct(t,e){const n=Bt,r=M(e*e*e,n),o=M(r*r*e,n);let i=M(t*r*Ot(t*o).pow_p_5_8,n);const s=M(e*i*i,n),f=i,c=M(i*xt,n),a=s===t,u=s===M(-t,n),l=s===M(-t*xt,n);return a&&(i=f),(u||l)&&(i=c),k(i,n)&&(i=M(-i,n)),{isValid:a||u,value:i}}const Nt=["0100000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a","0000000000000000000000000000000000000000000000000000000000000080","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05","ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85","0000000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"],Ut=(()=>K(Bt,void 0,!0))(),Tt=(()=>({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Ut,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:At,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:t,randomBytes:e,adjustScalarBytes:qt,uvRatio:Ct}))(),zt=(()=>ut(Tt))();function Pt(t,e,o){if(e.length>255)throw new Error("Context is too big");return r(n("SigEd25519 no Ed25519 collisions"),new Uint8Array([o?1:0,e.length]),e,t)}const Vt=(()=>ut({...Tt,domain:Pt}))(),Lt=(()=>ut(Object.assign({},Tt,{domain:Pt,prehash:t})))(),_t=(()=>Et({P:Bt,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:t=>{const e=Bt,{pow_p_5_8:n,b2:r}=Ot(t);return M(Z(n,St,e)*r,e)},adjustScalarBytes:qt,randomBytes:e}))();function Ft(t){const{y:e}=zt.ExtendedPoint.fromHex(t),n=BigInt(1);return Ut.toBytes(Ut.create((n+e)*Ut.inv(n-e)))}const Mt=Ft;function Dt(t){const e=Tt.hash(t.subarray(0,32));return Tt.adjustScalarBytes(e).subarray(0,32)}const Zt=(()=>(Ut.ORDER+St)/At)(),Ht=(()=>Ut.pow(It,Zt))(),jt=(()=>Ut.sqrt(Ut.neg(Ut.ONE)))();const kt=(()=>function(t,e){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const n=t.sqrt(e);return t.isOdd(n)?t.neg(n):n}(Ut,Ut.neg(BigInt(486664))))();function Gt(t){const{xMn:e,xMd:n,yMn:r,yMd:o}=function(t){const e=(Ut.ORDER-Rt)/At,n=BigInt(486662);let r=Ut.sqr(t);r=Ut.mul(r,It);let o=Ut.add(r,Ut.ONE),i=Ut.neg(n),s=Ut.sqr(o),f=Ut.mul(s,o),c=Ut.mul(r,n);c=Ut.mul(c,i),c=Ut.add(c,s),c=Ut.mul(c,i);let a=Ut.sqr(f);s=Ut.sqr(a),a=Ut.mul(a,f),a=Ut.mul(a,c),s=Ut.mul(s,a);let u=Ut.pow(s,e);u=Ut.mul(u,a);let l=Ut.mul(u,jt);s=Ut.sqr(u),s=Ut.mul(s,f);let d=Ut.eql(s,c),h=Ut.cmov(l,u,d),g=Ut.mul(i,r),w=Ut.mul(u,t);w=Ut.mul(w,Ht);let p=Ut.mul(w,jt),m=Ut.mul(c,r);s=Ut.sqr(w),s=Ut.mul(s,f);let y=Ut.eql(s,m),E=Ut.cmov(p,w,y);s=Ut.sqr(h),s=Ut.mul(s,f);let B=Ut.eql(s,c),x=Ut.cmov(g,i,B),b=Ut.cmov(E,h,B),v=Ut.isOdd(b);return b=Ut.cmov(b,Ut.neg(b),B!==v),{xMn:x,xMd:o,yMn:b,yMd:vt}}(t);let i=Ut.mul(e,o);i=Ut.mul(i,kt);let s=Ut.mul(n,r),f=Ut.sub(e,n),c=Ut.add(e,n),a=Ut.mul(s,c),u=Ut.eql(a,Ut.ZERO);i=Ut.cmov(i,Ut.ZERO,u),s=Ut.cmov(s,Ut.ONE,u),f=Ut.cmov(f,Ut.ONE,u),c=Ut.cmov(c,Ut.ONE,u);const l=Ut.invertBatch([s,c]);return{x:Ut.mul(i,l[0]),y:Ut.mul(f,l[1])}}const Wt=(()=>function(t,e,n){if("function"!=typeof e)throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const i=pt(r,2,{...n,DST:n.DST,...o}),s=t.fromAffine(e(i[0])),f=t.fromAffine(e(i[1])),c=s.add(f).clearCofactor();return c.assertValidity(),c},encodeToCurve(r,o){const i=pt(r,1,{...n,DST:n.encodeDST,...o}),s=t.fromAffine(e(i[0])).clearCofactor();return s.assertValidity(),s},mapToCurve(n){if(!Array.isArray(n))throw new Error("mapToCurve: expected array of bigints");for(const t of n)if("bigint"!=typeof t)throw new Error("mapToCurve: expected array of bigints");const r=t.fromAffine(e(n)).clearCofactor();return r.assertValidity(),r}}}(zt.ExtendedPoint,(t=>Gt(t[0])),{DST:"edwards25519_XMD:SHA-512_ELL2_RO_",encodeDST:"edwards25519_XMD:SHA-512_ELL2_NU_",p:Ut.ORDER,m:1,k:128,expand:"xmd",hash:t}))(),Kt=(()=>Wt.hashToCurve)(),Yt=(()=>Wt.encodeToCurve)();function Xt(t){if(!(t instanceof se))throw new Error("RistrettoPoint expected")}const Jt=xt,Qt=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),$t=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),te=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),ee=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),ne=t=>Ct(vt,t),re=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),oe=t=>zt.CURVE.Fp.create(b(t)&re);function ie(t){const{d:e}=zt.CURVE,n=zt.CURVE.Fp.ORDER,r=zt.CURVE.Fp.create,o=r(Jt*t*t),i=r((o+vt)*te);let s=BigInt(-1);const f=r((s-e*o)*r(o+e));let{isValid:c,value:a}=Ct(i,f),u=r(a*t);k(u,n)||(u=r(-u)),c||(a=u),c||(s=o);const l=r(s*(o-vt)*ee-f),d=a*a,h=r((a+a)*f),g=r(l*Qt),w=r(vt-d),p=r(vt+d);return new zt.ExtendedPoint(r(h*p),r(w*g),r(g*p),r(h*w))}class se{constructor(t){this.ep=t}static fromAffine(t){return new se(zt.ExtendedPoint.fromAffine(t))}static hashToCurve(t){t=S("ristrettoHash",t,64);const e=ie(oe(t.slice(0,32))),n=ie(oe(t.slice(32,64)));return new se(e.add(n))}static fromHex(t){t=S("ristrettoHex",t,32);const{a:e,d:n}=zt.CURVE,r=zt.CURVE.Fp.ORDER,o=zt.CURVE.Fp.create,i="RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint",s=oe(t);if(!function(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return 0===n}(I(s,32),t)||k(s,r))throw new Error(i);const f=o(s*s),c=o(vt+e*f),a=o(vt-e*f),u=o(c*c),l=o(a*a),d=o(e*n*u-l),{isValid:h,value:g}=ne(o(d*l)),w=o(g*a),p=o(g*w*d);let m=o((s+s)*w);k(m,r)&&(m=o(-m));const y=o(c*p),E=o(m*y);if(!h||k(E,r)||y===bt)throw new Error(i);return new se(new zt.ExtendedPoint(m,y,vt,E))}static msm(t,e){const n=K(zt.CURVE.n,zt.CURVE.nBitLength);return rt(se,n,t,e)}toRawBytes(){let{ex:t,ey:e,ez:n,et:r}=this.ep;const o=zt.CURVE.Fp.ORDER,i=zt.CURVE.Fp.create,s=i(i(n+e)*i(n-e)),f=i(t*e),c=i(f*f),{value:a}=ne(i(s*c)),u=i(a*s),l=i(a*f),d=i(u*l*r);let h;if(k(r*d,o)){let n=i(e*Jt),r=i(t*Jt);t=n,e=r,h=i(u*$t)}else h=l;k(t*d,o)&&(e=i(-e));let g=i((n-e)*h);return k(g,o)&&(g=i(-g)),I(g,32)}toHex(){return l(this.toRawBytes())}toString(){return this.toHex()}equals(t){Xt(t);const{ex:e,ey:n}=this.ep,{ex:r,ey:o}=t.ep,i=zt.CURVE.Fp.create,s=i(e*o)===i(n*r),f=i(n*o)===i(e*r);return s||f}add(t){return Xt(t),new se(this.ep.add(t.ep))}subtract(t){return Xt(t),new se(this.ep.subtract(t.ep))}multiply(t){return new se(this.ep.multiply(t))}multiplyUnsafe(t){return new se(this.ep.multiplyUnsafe(t))}double(){return new se(this.ep.double())}negate(){return new se(this.ep.negate())}}const fe=(()=>(se.BASE||(se.BASE=new se(zt.ExtendedPoint.BASE)),se.ZERO||(se.ZERO=new se(zt.ExtendedPoint.ZERO)),se))(),ce=(e,r)=>{const o=r.DST,i=wt(e,"string"==typeof o?n(o):o,64,t);return se.hashToCurve(i)},ae=ce;export{Nt as ED25519_TORSION_SUBGROUP,fe as RistrettoPoint,zt as ed25519,Vt as ed25519ctx,Lt as ed25519ph,Mt as edwardsToMontgomery,Dt as edwardsToMontgomeryPriv,Ft as edwardsToMontgomeryPub,Yt as encodeToCurve,Kt as hashToCurve,ce as hashToRistretto255,ae as hash_to_ristretto255,_t as x25519};export default null;
//# sourceMappingURL=/sm/3580f52fec3caa9d889937bc22675a32fbbd1a7bbf5030b4d2ce3c07d6e7fd55.map