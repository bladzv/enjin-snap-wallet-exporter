/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@noble/curves@1.8.1/esm/abstract/modular.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const t=BigInt(0),r=BigInt(1),n=BigInt(2);function e(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function o(t){if(!e(t))throw new Error("Uint8Array expected")}const i=Array.from({length:256},((t,r)=>r.toString(16).padStart(2,"0")));function u(t){o(t);let r="";for(let n=0;n<t.length;n++)r+=i[t[n]];return r}function f(r){if("string"!=typeof r)throw new Error("hex string expected, got "+typeof r);return""===r?t:BigInt("0x"+r)}const s=48,c=57,d=65,l=70,a=97,g=102;function w(t){return t>=s&&t<=c?t-s:t>=d&&t<=l?t-(d-10):t>=a&&t<=g?t-(a-10):void 0}function h(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const r=t.length,n=r/2;if(r%2)throw new Error("hex string expected, got unpadded hex of length "+r);const e=new Uint8Array(n);for(let r=0,o=0;r<n;r++,o+=2){const n=w(t.charCodeAt(o)),i=w(t.charCodeAt(o+1));if(void 0===n||void 0===i){const r=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+r+'" at index '+o)}e[r]=16*n+i}return e}function p(t){return f(u(t))}function E(t){return o(t),f(u(Uint8Array.from(t).reverse()))}function y(t,r){return h(t.toString(16).padStart(2*r,"0"))}function m(t,r){return y(t,r).reverse()}const v={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||e(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,r)=>r.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};const O=BigInt(0),b=BigInt(1),q=BigInt(2),x=BigInt(3),B=BigInt(4),I=BigInt(5),N=BigInt(8);function S(t,r){const n=t%r;return n>=O?n:r+n}function A(t,r,n){if(r<O)throw new Error("invalid exponent, negatives unsupported");if(n<=O)throw new Error("invalid modulus");if(n===b)return O;let e=b;for(;r>O;)r&b&&(e=e*t%n),t=t*t%n,r>>=b;return e}function R(t,r,n){let e=t;for(;r-- >O;)e*=e,e%=n;return e}function U(t,r){if(t===O)throw new Error("invert: expected non-zero number");if(r<=O)throw new Error("invert: expected positive modulus, got "+r);let n=S(t,r),e=r,o=O,i=b;for(;n!==O;){const t=e%n,r=o-i*(e/n);e=n,n=t,o=i,i=r}if(e!==b)throw new Error("invert: does not exist");return S(o,r)}function C(t){const r=(t-b)/q;let n,e,o;for(n=t-b,e=0;n%q===O;n/=q,e++);for(o=q;o<t&&A(o,r,t)!==t-b;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(1===e){const r=(t+b)/B;return function(t,n){const e=t.pow(n,r);if(!t.eql(t.sqr(e),n))throw new Error("Cannot find square root");return e}}const i=(n+b)/q;return function(t,u){if(t.pow(u,r)===t.neg(t.ONE))throw new Error("Cannot find square root");let f=e,s=t.pow(t.mul(t.ONE,o),n),c=t.pow(u,i),d=t.pow(u,n);for(;!t.eql(d,t.ONE);){if(t.eql(d,t.ZERO))return t.ZERO;let r=1;for(let n=t.sqr(d);r<f&&!t.eql(n,t.ONE);r++)n=t.sqr(n);const n=t.pow(s,b<<BigInt(f-r-1));s=t.sqr(n),c=t.mul(c,n),d=t.mul(d,s),f=r}return c}}function L(t){if(t%B===x){const r=(t+b)/B;return function(t,n){const e=t.pow(n,r);if(!t.eql(t.sqr(e),n))throw new Error("Cannot find square root");return e}}if(t%N===I){const r=(t-I)/N;return function(t,n){const e=t.mul(n,q),o=t.pow(e,r),i=t.mul(n,o),u=t.mul(t.mul(i,q),o),f=t.mul(i,t.sub(u,t.ONE));if(!t.eql(t.sqr(f),n))throw new Error("Cannot find square root");return f}}return C(t)}const D=(t,r)=>(S(t,r)&b)===b,M=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function T(t){return function(t,r,n={}){const e=(r,n,e)=>{const o=v[n];if("function"!=typeof o)throw new Error("invalid validator function");const i=t[r];if(!(e&&void 0===i||o(i,t)))throw new Error("param "+String(r)+" is invalid. Expected "+n+", got "+i)};for(const[t,n]of Object.entries(r))e(t,n,!1);for(const[t,r]of Object.entries(n))e(t,r,!0);return t}(t,M.reduce(((t,r)=>(t[r]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"}))}function j(t,r,n){if(n<O)throw new Error("invalid exponent, negatives unsupported");if(n===O)return t.ONE;if(n===b)return r;let e=t.ONE,o=r;for(;n>O;)n&b&&(e=t.mul(e,o)),o=t.sqr(o),n>>=b;return e}function F(t,r){const n=new Array(r.length),e=r.reduce(((r,e,o)=>t.is0(e)?r:(n[o]=r,t.mul(r,e))),t.ONE),o=t.inv(e);return r.reduceRight(((r,e,o)=>t.is0(e)?r:(n[o]=t.mul(r,n[o]),t.mul(r,e))),o),n}function V(t,r,n){return t.mul(r,"bigint"==typeof n?U(n,t.ORDER):t.inv(n))}function Z(t){const r=(t-b)/q;return(t,n)=>t.pow(n,r)}function z(t){const r=Z(t.ORDER);return n=>{const e=r(t,n);return t.eql(e,t.ZERO)||t.eql(e,t.ONE)}}function K(t,r){const n=void 0!==r?r:t.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function P(t,e,o=!1,i={}){if(t<=O)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:u,nByteLength:f}=K(t,e);if(f>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let s;const c=Object.freeze({ORDER:t,isLE:o,BITS:u,BYTES:f,MASK:(d=u,(n<<BigInt(d-1))-r),ZERO:O,ONE:b,create:r=>S(r,t),isValid:r=>{if("bigint"!=typeof r)throw new Error("invalid field element: expected bigint, got "+typeof r);return O<=r&&r<t},is0:t=>t===O,isOdd:t=>(t&b)===b,neg:r=>S(-r,t),eql:(t,r)=>t===r,sqr:r=>S(r*r,t),add:(r,n)=>S(r+n,t),sub:(r,n)=>S(r-n,t),mul:(r,n)=>S(r*n,t),pow:(t,r)=>j(c,t,r),div:(r,n)=>S(r*U(n,t),t),sqrN:t=>t*t,addN:(t,r)=>t+r,subN:(t,r)=>t-r,mulN:(t,r)=>t*r,inv:r=>U(r,t),sqrt:i.sqrt||(r=>(s||(s=L(t)),s(c,r))),invertBatch:t=>F(c,t),cmov:(t,r,n)=>n?r:t,toBytes:t=>o?m(t,f):y(t,f),fromBytes:t=>{if(t.length!==f)throw new Error("Field.fromBytes: expected "+f+" bytes, got "+t.length);return o?E(t):p(t)}});var d;return Object.freeze(c)}function Y(t,r){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const n=t.sqrt(r);return t.isOdd(n)?n:t.neg(n)}function k(t,r){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const n=t.sqrt(r);return t.isOdd(n)?t.neg(n):n}function H(t,r,n=!1){const o=(t=function(t,r,n){let o;if("string"==typeof r)try{o=h(r)}catch(r){throw new Error(t+" must be hex string or Uint8Array, cause: "+r)}else{if(!e(r))throw new Error(t+" must be hex string or Uint8Array");o=Uint8Array.from(r)}const i=o.length;if("number"==typeof n&&i!==n)throw new Error(t+" of length "+n+" expected, got "+i);return o}("privateHash",t)).length,i=K(r).nByteLength+8;if(i<24||o<i||o>1024)throw new Error("hashToPrivateScalar: expected "+i+"-1024 bytes of input, got "+o);return S(n?E(t):p(t),r-b)+b}function G(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const r=t.toString(2).length;return Math.ceil(r/8)}function J(t){const r=G(t);return r+Math.ceil(r/2)}function Q(t,r,n=!1){const e=t.length,o=G(r),i=J(r);if(e<16||e<i||e>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+e);const u=S(n?E(t):p(t),r-b)+b;return n?m(u,o):y(u,o)}export{P as Field,V as FpDiv,F as FpInvertBatch,z as FpIsSquare,Z as FpLegendre,j as FpPow,L as FpSqrt,k as FpSqrtEven,Y as FpSqrtOdd,G as getFieldBytesLength,J as getMinHashLength,H as hashToPrivateScalar,U as invert,D as isNegativeLE,Q as mapHashToField,S as mod,K as nLength,A as pow,R as pow2,C as tonelliShanks,T as validateField};export default null;
//# sourceMappingURL=/sm/0d055f7a4c3ec1a928ca6cfe41ef4487f99d973318f0ebb4501372a781e867ff.map