export const packageInfo = { name: '@polkadot/wasm-crypto', version: '7.4.1' };

export async function wasmInit() {
  // No-op shim for offline usage when actual WASM binary is unavailable.
  return true;
}

export const isReady = true;

export default { wasmInit, isReady };
/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@polkadot/wasm-crypto@7.4.1/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{detectPackage as a}from"/npm/@polkadot/util@13.5.1/+esm.js";import{packageInfo as l}from"/npm/@polkadot/wasm-bridge@7.4.1/packageInfo/+esm.js";import{packageInfo as e}from"/npm/@polkadot/wasm-crypto-asmjs@7.4.1/packageInfo/+esm.js";import{packageInfo as t}from"/npm/@polkadot/wasm-crypto-init@7.4.1/packageInfo/+esm.js";import{packageInfo as o}from"/npm/@polkadot/wasm-crypto-wasm@7.4.1/packageInfo/+esm.js";import{packageInfo as r}from"/npm/@polkadot/wasm-util@7.4.1/packageInfo/+esm.js";import{Bridge as c}from"/npm/@polkadot/wasm-bridge@7.4.1/+esm.js";import{createWasm as s}from"/npm/@polkadot/wasm-crypto-init@7.4.1/+esm.js";const U={name:"@polkadot/wasm-crypto",path:import.meta&&import.meta.url?new URL(import.meta.url).pathname.substring(0,new URL(import.meta.url).pathname.lastIndexOf("/")+1):"auto",type:"esm",version:"7.4.1"};a(U,null,[e,l,t,r,o]);const n=new c(s);function i(a){return(...l)=>{if(!n.wasm)throw new Error("The WASM interface has not been initialized. Ensure that you wait for the initialization Promise with waitReady() from @polkadot/wasm-crypto (or cryptoWaitReady() from @polkadot/util-crypto) before attempting to use WASM-only interfaces.");return a(n.wasm,...l)}}const p=i(((a,l)=>(a.ext_bip39_generate(8,l),n.resultString()))),_=i(((a,l)=>(a.ext_bip39_to_entropy(8,...n.allocString(l)),n.resultU8a()))),m=i(((a,l,e)=>(a.ext_bip39_to_mini_secret(8,...n.allocString(l),...n.allocString(e)),n.resultU8a()))),u=i(((a,l,e)=>(a.ext_bip39_to_seed(8,...n.allocString(l),...n.allocString(e)),n.resultU8a()))),f=i(((a,l)=>0!==a.ext_bip39_validate(...n.allocString(l)))),x=i(((a,l)=>(a.ext_ed_from_seed(8,...n.allocU8a(l)),n.resultU8a()))),d=i(((a,l,e,t)=>(a.ext_ed_sign(8,...n.allocU8a(l),...n.allocU8a(e),...n.allocU8a(t)),n.resultU8a()))),k=i(((a,l,e,t)=>0!==a.ext_ed_verify(...n.allocU8a(l),...n.allocU8a(e),...n.allocU8a(t)))),g=i(((a,l)=>(a.ext_secp_from_seed(8,...n.allocU8a(l)),n.resultU8a()))),w=i(((a,l)=>(a.ext_secp_pub_compress(8,...n.allocU8a(l)),n.resultU8a()))),y=i(((a,l)=>(a.ext_secp_pub_expand(8,...n.allocU8a(l)),n.resultU8a()))),h=i(((a,l,e,t)=>(a.ext_secp_recover(8,...n.allocU8a(l),...n.allocU8a(e),t),n.resultU8a()))),b=i(((a,l,e)=>(a.ext_secp_sign(8,...n.allocU8a(l),...n.allocU8a(e)),n.resultU8a()))),v=i(((a,l,e)=>(a.ext_sr_derive_keypair_hard(8,...n.allocU8a(l),...n.allocU8a(e)),n.resultU8a()))),I=i(((a,l,e)=>(a.ext_sr_derive_keypair_soft(8,...n.allocU8a(l),...n.allocU8a(e)),n.resultU8a()))),S=i(((a,l,e)=>(a.ext_sr_derive_public_soft(8,...n.allocU8a(l),...n.allocU8a(e)),n.resultU8a()))),R=i(((a,l)=>(a.ext_sr_from_seed(8,...n.allocU8a(l)),n.resultU8a()))),W=i(((a,l,e,t)=>(a.ext_sr_sign(8,...n.allocU8a(l),...n.allocU8a(e),...n.allocU8a(t)),n.resultU8a()))),z=i(((a,l,e,t)=>0!==a.ext_sr_verify(...n.allocU8a(l),...n.allocU8a(e),...n.allocU8a(t)))),A=i(((a,l,e)=>(a.ext_sr_agree(8,...n.allocU8a(l),...n.allocU8a(e)),n.resultU8a()))),E=i(((a,l,e,t,o)=>(a.ext_vrf_sign(8,...n.allocU8a(l),...n.allocU8a(e),...n.allocU8a(t),...n.allocU8a(o)),n.resultU8a()))),L=i(((a,l,e,t,o,r)=>0!==a.ext_vrf_verify(...n.allocU8a(l),...n.allocU8a(e),...n.allocU8a(t),...n.allocU8a(o),...n.allocU8a(r)))),M=i(((a,l,e,t)=>(a.ext_blake2b(8,...n.allocU8a(l),...n.allocU8a(e),t),n.resultU8a()))),j=i(((a,l,e)=>(a.ext_hmac_sha256(8,...n.allocU8a(l),...n.allocU8a(e)),n.resultU8a()))),O=i(((a,l,e)=>(a.ext_hmac_sha512(8,...n.allocU8a(l),...n.allocU8a(e)),n.resultU8a()))),P=i(((a,l)=>(a.ext_keccak256(8,...n.allocU8a(l)),n.resultU8a()))),T=i(((a,l)=>(a.ext_keccak512(8,...n.allocU8a(l)),n.resultU8a()))),q=i(((a,l,e,t)=>(a.ext_pbkdf2(8,...n.allocU8a(l),...n.allocU8a(e),t),n.resultU8a()))),B=i(((a,l,e,t,o,r)=>(a.ext_scrypt(8,...n.allocU8a(l),...n.allocU8a(e),t,o,r),n.resultU8a()))),C=i(((a,l)=>(a.ext_sha256(8,...n.allocU8a(l)),n.resultU8a()))),D=i(((a,l)=>(a.ext_sha512(8,...n.allocU8a(l)),n.resultU8a()))),F=i(((a,l,e)=>(a.ext_twox(8,...n.allocU8a(l),e),n.resultU8a())));function G(){return!!n.wasm}async function H(){try{const a=await async function(a){return n.init(a)}();return!!a}catch{return!1}}export{p as bip39Generate,_ as bip39ToEntropy,m as bip39ToMiniSecret,u as bip39ToSeed,f as bip39Validate,M as blake2b,n as bridge,x as ed25519KeypairFromSeed,d as ed25519Sign,k as ed25519Verify,j as hmacSha256,O as hmacSha512,G as isReady,P as keccak256,T as keccak512,U as packageInfo,q as pbkdf2,B as scrypt,w as secp256k1Compress,y as secp256k1Expand,g as secp256k1FromSeed,h as secp256k1Recover,b as secp256k1Sign,C as sha256,D as sha512,A as sr25519Agree,v as sr25519DeriveKeypairHard,I as sr25519DeriveKeypairSoft,S as sr25519DerivePublicSoft,R as sr25519KeypairFromSeed,W as sr25519Sign,z as sr25519Verify,F as twox,E as vrfSign,L as vrfVerify,H as waitReady};export default null;
//# sourceMappingURL=/sm/d116fa3df0cdee2cd94da1257ff39b08a0d7783955adf6c98873f957e1e43c75.map